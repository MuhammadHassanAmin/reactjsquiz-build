(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[50938],{90414:function(e,s,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/react-memoization-techniques-usememo-vs-usecallback",function(){return n(71241)}])},23862:function(e,s,n){"use strict";var t=n(85893);s.Z=e=>{let{title:s,categories:n,level:a,date:o,children:c}=e;return(0,t.jsxs)("article",{className:"p-6 px-6 md:px-10 dark:text-white rounded-lg overflow-hidden",children:[(0,t.jsxs)("header",{className:"mb-4",children:[(0,t.jsx)("h1",{className:"text-2xl md:text-4xl font-bold text-center mb-8 break-words",children:s}),(0,t.jsxs)("div",{className:"border-y border-stone-500 py-2 my-4 text-center text-xs md:text-sm break-words",children:[(0,t.jsxs)("span",{className:"block",children:["Category: ",n.join(", ")]}),(0,t.jsxs)("span",{className:"block mx-5",children:["Difficulty: ",a]}),(0,t.jsxs)("span",{className:"block",children:["Published on: ",o]})]})]}),(0,t.jsx)("div",{className:"break-words",children:c})]})}},96828:function(e,s,n){"use strict";var t=n(85893);s.Z=e=>{let{children:s}=e;return(0,t.jsx)("div",{className:"w-full overflow-x-auto max-w-[350px] md:max-w-none ",children:(0,t.jsx)("pre",{className:"bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 dark:text-slate-300",children:(0,t.jsx)("code",{className:"whitespace-pre-wrap break-words",children:s})})})}},25190:function(e,s,n){"use strict";n.d(s,{Z:function(){return m}});var t=n(85893),a=n(67294),o=n(94184),c=n.n(o),i=n(41664),l=n.n(i),r=JSON.parse('{"u2":"React JS Quiz","ow":[{"title":"Javascript Quiz","url":"https://javascriptquiz.app","target":"_blank","badge":"New"}]}');let d=e=>{let{link:s,title:n,className:a,target:o,badge:c}=e;return(0,t.jsx)(l(),{passHref:!0,href:s,className:"flex mb-1 relative",target:o,rel:"_blank"===o?"noopener noreferrer":void 0,children:(0,t.jsxs)("span",{className:"px-2 py-1 w-full text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2",children:[n,c&&(0,t.jsx)("span",{className:"absolute -top-1  -right-8 -z-1  px-2 text-[10px] font-bold text-white bg-yellow-500 rounded-full",children:"New"})]})})};var h=e=>{let[s,n]=(0,a.useState)(!1),o=e.siteName||r.u2,i=e.navbarLinks||r.ow||[];return(0,t.jsx)("nav",{className:"bg-white shadow dark:bg-gray-800",children:(0,t.jsxs)("div",{className:"container px-6 py-3 mx-auto md:flex ",children:[(0,t.jsxs)("div",{className:"flex items-center justify-between w-full  ",children:[(0,t.jsx)(l(),{href:"/",passHref:!0,children:(0,t.jsx)("span",{className:"whitespace-nowrap text-2xl font-bold text-gray-800 transition-colors duration-200 transform dark:text-white lg:text-3xl hover:text-gray-700 dark:hover:text-gray-300",children:o})}),(0,t.jsx)("div",{className:"flex md:hidden",children:(0,t.jsx)("button",{type:"button",onClick:()=>{n(!s)},className:"text-gray-500 dark:text-gray-200 hover:text-gray-600 dark:hover:text-gray-400 focus:outline-none focus:text-gray-600 dark:focus:text-gray-400","aria-label":"toggle menu",children:(0,t.jsx)("svg",{viewBox:"0 0 24 24",className:"w-6 h-6 fill-current",children:(0,t.jsx)("path",{fillRule:"evenodd",d:"M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"})})})})]}),(0,t.jsx)("div",{className:c()("w-full md:flex md:items-center md:justify-end",{block:s,hidden:!s}),children:(0,t.jsxs)("div",{className:"flex flex-col px-2 py-3 -mx-4 md:flex-row md:mx-0 md:py-0 text-2xl",children:[(0,t.jsx)(d,{link:"/",title:"Home",className:"w-full bg-black"}),(0,t.jsx)(d,{link:"/blog",title:"Blog"}),(0,t.jsx)(d,{link:"/privacy-policy",title:"Privacy Policy"}),(0,t.jsx)(d,{link:"/contact-us",title:"Contact Us"}),i.map((e,s)=>(0,t.jsx)(d,{link:e.url,title:e.title,target:e.target,badge:e.badge},s))]})})]})})};function m(e){return class extends a.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)("header",{className:"border-b",children:(0,t.jsx)(h,{siteName:this.props.siteName})}),(0,t.jsx)("main",{className:" flex flex-col justify-center items-center py-5 h-full",children:(0,t.jsx)(e,{...this.props})}),(0,t.jsx)("footer",{className:"bg-white dark:bg-gray-800 dark:text-white p-5 border-t-2  flex flex-col justify-center items-center "})]})}constructor(e){super(e)}}}},71241:function(e,s,n){"use strict";n.r(s),n.d(s,{__N_SSG:function(){return i}});var t=n(85893),a=n(25190),o=n(96828),c=n(23862),i=!0;s.default=(0,a.Z)(e=>{let{title:s,date:n,categories:a,level:i}=e;return(0,t.jsx)(c.Z,{title:s,categories:a,level:i,date:n,children:(0,t.jsxs)("div",{className:"container mx-auto px-4 py-8",children:[(0,t.jsxs)("p",{className:"mb-4",children:["Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again. In React, memoization helps in optimizing the rendering process, especially when dealing with complex components or expensive operations. Two common hooks used for memoization in React are ",(0,t.jsx)("code",{children:"useMemo"})," and"," ",(0,t.jsx)("code",{children:"useCallback"}),". In this article, we’ll dive into what these hooks are, how they work, and when to use each."]}),(0,t.jsx)("h2",{className:"text-2xl font-semibold mb-4",children:"Understanding Memoization in React"}),(0,t.jsx)("p",{className:"mb-4",children:"React’s rendering process can be optimized using memoization techniques. When a component re-renders, React checks if the output of the component has changed. If the output hasn’t changed, React can skip rendering and reuse the previous output, which improves performance. Memoization helps achieve this by caching the results of function calls or component renders based on their dependencies."}),(0,t.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["The ",(0,t.jsx)("code",{children:"useMemo"})," Hook"]}),(0,t.jsxs)("p",{className:"mb-4",children:["The ",(0,t.jsx)("code",{children:"useMemo"})," hook is used to memoize expensive calculations or derived values within a component. It returns a memoized value that only changes when one of its dependencies changes. This can help avoid unnecessary recalculations and improve performance. Here’s the basic syntax of ",(0,t.jsx)("code",{children:"useMemo"}),":"]}),(0,t.jsx)(o.Z,{children:"const memoizedValue = useMemo(() => {\n  // Expensive calculation\n  return computedValue;\n}, [dependencies]);"}),(0,t.jsxs)("p",{className:"mb-4",children:["In this example, the expensive calculation will only be recomputed if one of the ",(0,t.jsx)("code",{children:"dependencies"})," changes. Otherwise, the previously memoized value will be returned, avoiding redundant calculations."]}),(0,t.jsx)("h3",{className:"text-xl font-medium mb-4",children:"Example: Memoizing a Computed Value"}),(0,t.jsxs)("p",{className:"mb-4",children:["Let’s say you have a component that performs an expensive calculation based on some props. You can use ",(0,t.jsx)("code",{children:"useMemo"})," to optimize this:"]}),(0,t.jsx)(o.Z,{children:"import React, { useMemo } from 'react';\n\nfunction ExpensiveComponent({ data }) {\n  const processedData = useMemo(() => {\n    // Simulate an expensive calculation\n    return data.reduce((acc, item) => acc + item.value, 0);\n  }, [data]);\n\n  return <div>Total: {processedData}</div>;\n}"}),(0,t.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,t.jsx)("code",{children:"processedData"})," calculation will only be recomputed if the ",(0,t.jsx)("code",{children:"data"})," prop changes, improving performance by avoiding unnecessary recalculations."]}),(0,t.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["The ",(0,t.jsx)("code",{children:"useCallback"})," Hook"]}),(0,t.jsxs)("p",{className:"mb-4",children:["The ",(0,t.jsx)("code",{children:"useCallback"})," hook is used to memoize callback functions, preventing their recreation on every render. This is particularly useful when passing callbacks to child components that depend on reference equality to prevent unnecessary re-renders. Here’s the basic syntax of ",(0,t.jsx)("code",{children:"useCallback"}),":"]}),(0,t.jsx)(o.Z,{children:"const memoizedCallback = useCallback(() => {\n  // Callback logic\n}, [dependencies]);"}),(0,t.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,t.jsx)("code",{children:"memoizedCallback"})," will only be recreated if one of its ",(0,t.jsx)("code",{children:"dependencies"})," changes. This ensures that the same function reference is used unless dependencies change."]}),(0,t.jsx)("h3",{className:"text-xl font-medium mb-4",children:"Example: Memoizing a Callback Function"}),(0,t.jsxs)("p",{className:"mb-4",children:["Suppose you have a component with a callback function that is passed to a child component. You can use ",(0,t.jsx)("code",{children:"useCallback"})," to memoize this function:"]}),(0,t.jsx)(o.Z,{children:"import React, { useCallback } from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n  const handleClick = useCallback(() => {\n    console.log('Button clicked');\n  }, []);\n\n  return <ChildComponent onClick={handleClick} />;\n}"}),(0,t.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,t.jsx)("code",{children:"handleClick"})," function will only be recreated if its dependencies change (in this case, there are no dependencies). This ensures that the ",(0,t.jsx)("code",{children:"ChildComponent"})," ","receives the same function reference unless it needs to change."]}),(0,t.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["When to Use ",(0,t.jsx)("code",{children:"useMemo"})," vs ",(0,t.jsx)("code",{children:"useCallback"})]}),(0,t.jsxs)("p",{className:"mb-4",children:["Both ",(0,t.jsx)("code",{children:"useMemo"})," and ",(0,t.jsx)("code",{children:"useCallback"})," serve different purposes, and choosing between them depends on what you need to optimize:"]}),(0,t.jsxs)("ul",{className:"list-disc pl-6 mb-4",children:[(0,t.jsxs)("li",{className:"mb-2",children:["Use ",(0,t.jsx)("code",{children:"useMemo"})," when you need to memoize the result of a computation or derived value. It’s useful for expensive calculations that you want to avoid recomputing unnecessarily."]}),(0,t.jsxs)("li",{className:"mb-2",children:["Use ",(0,t.jsx)("code",{children:"useCallback"})," when you need to memoize a function that is passed to child components. It’s useful for preventing unnecessary re-renders of child components that rely on reference equality."]})]}),(0,t.jsxs)("p",{className:"mb-4",children:["In summary, both hooks are valuable tools in optimizing React applications. Use ",(0,t.jsx)("code",{children:"useMemo"})," to cache computed values and"," ",(0,t.jsx)("code",{children:"useCallback"})," to cache functions, helping you avoid performance bottlenecks and unnecessary re-renders."]})]})})})}},function(e){e.O(0,[41966,92888,49774,40179],function(){return e(e.s=90414)}),_N_E=e.O()}]);