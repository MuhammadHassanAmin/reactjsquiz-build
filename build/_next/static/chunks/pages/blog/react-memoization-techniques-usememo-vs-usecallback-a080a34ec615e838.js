(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[938],{414:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/react-memoization-techniques-usememo-vs-usecallback",function(){return n(1241)}])},3862:function(e,t,n){"use strict";var a=n(5893);t.Z=e=>{let{title:t,categories:n,level:s,date:i,children:o}=e;return(0,a.jsxs)("article",{className:"p-6 px-6 md:px-10 dark:text-white rounded-lg overflow-hidden",children:[(0,a.jsxs)("header",{className:"mb-4",children:[(0,a.jsx)("h1",{className:"text-2xl md:text-4xl font-bold text-center mb-8 break-words",children:t}),(0,a.jsxs)("div",{className:"border-y border-stone-500 py-2 my-4 text-center text-xs md:text-sm break-words",children:[(0,a.jsxs)("span",{className:"block",children:["Category: ",n.join(", ")]}),(0,a.jsxs)("span",{className:"block mx-5",children:["Difficulty: ",s]}),(0,a.jsxs)("span",{className:"block",children:["Published on: ",i]})]})]}),(0,a.jsx)("div",{className:"break-words",children:o})]})}},6828:function(e,t,n){"use strict";var a=n(5893);t.Z=e=>{let{children:t}=e;return(0,a.jsx)("div",{className:"w-full overflow-x-auto max-w-[350px] md:max-w-none",children:(0,a.jsx)("pre",{className:"bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 text-slate-300",children:(0,a.jsx)("code",{className:"whitespace-pre-wrap break-words",children:t})})})}},1354:function(e,t,n){"use strict";n.d(t,{Z:function(){return h}});var a=n(5893),s=n(7294),i=n(4184),o=n.n(i),r=n(1664),c=n.n(r);let l=e=>{let{link:t,title:n,className:s}=e;return(0,a.jsx)(c(),{href:t,className:"flex mb-1",children:(0,a.jsx)("span",{className:"px-2 py-1 w-full  text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2",children:n})})};var d=()=>{let[e,t]=(0,s.useState)(!1);return(0,a.jsx)("nav",{className:"bg-white shadow dark:bg-gray-800",children:(0,a.jsxs)("div",{className:"container px-6 py-3 mx-auto md:flex ",children:[(0,a.jsxs)("div",{className:"flex items-center justify-between w-full  ",children:[(0,a.jsx)(c(),{href:"/",children:(0,a.jsx)("span",{className:"whitespace-nowrap text-2xl font-bold text-gray-800 transition-colors duration-200 transform dark:text-white lg:text-3xl hover:text-gray-700 dark:hover:text-gray-300",children:"React Js Quiz"})}),(0,a.jsx)("div",{className:"flex md:hidden",children:(0,a.jsx)("button",{type:"button",onClick:()=>{t(!e)},className:"text-gray-500 dark:text-gray-200 hover:text-gray-600 dark:hover:text-gray-400 focus:outline-none focus:text-gray-600 dark:focus:text-gray-400","aria-label":"toggle menu",children:(0,a.jsx)("svg",{viewBox:"0 0 24 24",className:"w-6 h-6 fill-current",children:(0,a.jsx)("path",{fillRule:"evenodd",d:"M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"})})})})]}),(0,a.jsx)("div",{className:o()("w-full md:flex md:items-center md:justify-end",{block:e,hidden:!e}),children:(0,a.jsxs)("div",{className:"flex flex-col px-2 py-3 -mx-4 md:flex-row md:mx-0 md:py-0 text-2xl",children:[(0,a.jsx)(l,{link:"/",title:"Home",className:"w-full bg-black"}),(0,a.jsx)(l,{link:"/blog",title:"Blog"}),(0,a.jsx)(l,{link:"/privacy-policy",title:"Privacy Policy"}),(0,a.jsx)(l,{link:"/contact-us",title:"Contact Us"})]})})]})})};function h(e){return class extends s.Component{componentDidMount(){console.log("Wrapped Component")}render(){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)("header",{className:"border-b",children:(0,a.jsx)(d,{})}),(0,a.jsx)("main",{className:" flex flex-col justify-center items-center py-5 h-full",children:(0,a.jsx)(e,{...this.props})}),(0,a.jsx)("footer",{className:"bg-white dark:bg-gray-800 dark:text-white p-5 border-t-2  flex flex-col justify-center items-center ",children:(0,a.jsx)(c(),{href:"/",rel:"noopener noreferrer",children:"Powered by React JS Quiz"})})]})}constructor(e){super(e)}}}},1241:function(e,t,n){"use strict";n.r(t),n.d(t,{__N_SSG:function(){return m}});var a=n(5893),s=n(1354),i=n(6828),o=n(8974),r=n(3862);let{title:c,date:l,categories:d,level:h}=o.find(e=>8===e.id);var m=!0;t.default=(0,s.Z)(e=>{let{}=e;return(0,a.jsx)(r.Z,{title:c,categories:d,level:h,date:l,children:(0,a.jsxs)("div",{className:"container mx-auto px-4 py-8",children:[(0,a.jsxs)("p",{className:"mb-4",children:["Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again. In React, memoization helps in optimizing the rendering process, especially when dealing with complex components or expensive operations. Two common hooks used for memoization in React are ",(0,a.jsx)("code",{children:"useMemo"})," and"," ",(0,a.jsx)("code",{children:"useCallback"}),". In this article, we’ll dive into what these hooks are, how they work, and when to use each."]}),(0,a.jsx)("h2",{className:"text-2xl font-semibold mb-4",children:"Understanding Memoization in React"}),(0,a.jsx)("p",{className:"mb-4",children:"React’s rendering process can be optimized using memoization techniques. When a component re-renders, React checks if the output of the component has changed. If the output hasn’t changed, React can skip rendering and reuse the previous output, which improves performance. Memoization helps achieve this by caching the results of function calls or component renders based on their dependencies."}),(0,a.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["The ",(0,a.jsx)("code",{children:"useMemo"})," Hook"]}),(0,a.jsxs)("p",{className:"mb-4",children:["The ",(0,a.jsx)("code",{children:"useMemo"})," hook is used to memoize expensive calculations or derived values within a component. It returns a memoized value that only changes when one of its dependencies changes. This can help avoid unnecessary recalculations and improve performance. Here’s the basic syntax of ",(0,a.jsx)("code",{children:"useMemo"}),":"]}),(0,a.jsx)(i.Z,{children:"const memoizedValue = useMemo(() => {\n  // Expensive calculation\n  return computedValue;\n}, [dependencies]);"}),(0,a.jsxs)("p",{className:"mb-4",children:["In this example, the expensive calculation will only be recomputed if one of the ",(0,a.jsx)("code",{children:"dependencies"})," changes. Otherwise, the previously memoized value will be returned, avoiding redundant calculations."]}),(0,a.jsx)("h3",{className:"text-xl font-medium mb-4",children:"Example: Memoizing a Computed Value"}),(0,a.jsxs)("p",{className:"mb-4",children:["Let’s say you have a component that performs an expensive calculation based on some props. You can use ",(0,a.jsx)("code",{children:"useMemo"})," to optimize this:"]}),(0,a.jsx)(i.Z,{children:"import React, { useMemo } from 'react';\n\nfunction ExpensiveComponent({ data }) {\n  const processedData = useMemo(() => {\n    // Simulate an expensive calculation\n    return data.reduce((acc, item) => acc + item.value, 0);\n  }, [data]);\n\n  return <div>Total: {processedData}</div>;\n}"}),(0,a.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,a.jsx)("code",{children:"processedData"})," calculation will only be recomputed if the ",(0,a.jsx)("code",{children:"data"})," prop changes, improving performance by avoiding unnecessary recalculations."]}),(0,a.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["The ",(0,a.jsx)("code",{children:"useCallback"})," Hook"]}),(0,a.jsxs)("p",{className:"mb-4",children:["The ",(0,a.jsx)("code",{children:"useCallback"})," hook is used to memoize callback functions, preventing their recreation on every render. This is particularly useful when passing callbacks to child components that depend on reference equality to prevent unnecessary re-renders. Here’s the basic syntax of ",(0,a.jsx)("code",{children:"useCallback"}),":"]}),(0,a.jsx)(i.Z,{children:"const memoizedCallback = useCallback(() => {\n  // Callback logic\n}, [dependencies]);"}),(0,a.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,a.jsx)("code",{children:"memoizedCallback"})," will only be recreated if one of its ",(0,a.jsx)("code",{children:"dependencies"})," changes. This ensures that the same function reference is used unless dependencies change."]}),(0,a.jsx)("h3",{className:"text-xl font-medium mb-4",children:"Example: Memoizing a Callback Function"}),(0,a.jsxs)("p",{className:"mb-4",children:["Suppose you have a component with a callback function that is passed to a child component. You can use ",(0,a.jsx)("code",{children:"useCallback"})," to memoize this function:"]}),(0,a.jsx)(i.Z,{children:"import React, { useCallback } from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n  const handleClick = useCallback(() => {\n    console.log('Button clicked');\n  }, []);\n\n  return <ChildComponent onClick={handleClick} />;\n}"}),(0,a.jsxs)("p",{className:"mb-4",children:["In this example, the ",(0,a.jsx)("code",{children:"handleClick"})," function will only be recreated if its dependencies change (in this case, there are no dependencies). This ensures that the ",(0,a.jsx)("code",{children:"ChildComponent"})," ","receives the same function reference unless it needs to change."]}),(0,a.jsxs)("h2",{className:"text-2xl font-semibold mb-4",children:["When to Use ",(0,a.jsx)("code",{children:"useMemo"})," vs ",(0,a.jsx)("code",{children:"useCallback"})]}),(0,a.jsxs)("p",{className:"mb-4",children:["Both ",(0,a.jsx)("code",{children:"useMemo"})," and ",(0,a.jsx)("code",{children:"useCallback"})," serve different purposes, and choosing between them depends on what you need to optimize:"]}),(0,a.jsxs)("ul",{className:"list-disc pl-6 mb-4",children:[(0,a.jsxs)("li",{className:"mb-2",children:["Use ",(0,a.jsx)("code",{children:"useMemo"})," when you need to memoize the result of a computation or derived value. It’s useful for expensive calculations that you want to avoid recomputing unnecessarily."]}),(0,a.jsxs)("li",{className:"mb-2",children:["Use ",(0,a.jsx)("code",{children:"useCallback"})," when you need to memoize a function that is passed to child components. It’s useful for preventing unnecessary re-renders of child components that rely on reference equality."]})]}),(0,a.jsxs)("p",{className:"mb-4",children:["In summary, both hooks are valuable tools in optimizing React applications. Use ",(0,a.jsx)("code",{children:"useMemo"})," to cache computed values and"," ",(0,a.jsx)("code",{children:"useCallback"})," to cache functions, helping you avoid performance bottlenecks and unnecessary re-renders."]})]})})})},8974:function(e){"use strict";e.exports=JSON.parse('[{"id":10,"title":"React DevTools: A Guide for Debugging Your React Apps","description":"Debugging is an essential part of developing React applications. React DevTools is a powerful browser extension that provides a set of tools to help you inspect and debug your React components. In this article, we\'ll explore the features of React DevTools and how you can use them to enhance your development workflow.","categories":["Interview","Concept","Debugging"],"date":"8 September 2024","path":"/blog/react-devtools-a-guide-for-debugging-your-react-apps","imageProps":{"alt":"devtools","src":"/icons/devtools.svg"},"level":"Intermediate"},{"id":9,"title":"How to Manage Side Effects with useEffect in React","description":"Managing side effects is a crucial aspect of developing React applications. Side effects can include operations like data fetching, subscriptions, or manually changing the DOM.","categories":["Interview","Concept"],"date":"5 September 2024","path":"/blog/how-to-manage-side-effects-with-useeffect-in-react","imageProps":{"alt":"arrow-repeat","src":"/icons/arrow-repeat.svg"},"level":"Beginner"},{"id":8,"title":"React Memoization Techniques: useMemo vs useCallback","description":"Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again.","categories":["Interview","Concept"],"date":"1 September 2024","path":"/blog/react-memoization-techniques-usememo-vs-usecallback","imageProps":{"alt":"memory","src":"/icons/memory.svg"},"level":"Intermediate"},{"id":7,"title":"Integrating Third-Party Libraries in React","description":" When building React applications, you’ll often need to integrate third-party libraries to enhance functionality. React’s flexibility allows seamless integration with various libraries, whether for UI, state management, or utility functions.","categories":["Interview","Concept"],"date":"25 August 2024","path":"/blog/integrating-third-party-libraries-in-react","imageProps":{"alt":"integration","src":"/icons/integration.svg"},"level":"Beginner"},{"id":6,"title":"Understanding Refs in React and When to Use Them","description":"React is all about components and managing the state, but sometimes, you need direct access to DOM elements or a specific React component instance.","categories":["Interview","Concept"],"date":"20 August 2024","path":"/blog/understanding-refs-in-react-and-when-to-use-them","imageProps":{"alt":"model-builder-reference","src":"/icons/model-builder-reference.svg"},"level":"Intermediate"},{"id":5,"title":"Understanding Prop Drilling in React and How to Avoid It","description":"","categories":["Interview","Concept","Performance"],"date":"18 August 2024","path":"/blog/understanding-prop-drilling-in-react-and-how-to-avoid-it","imageProps":{"alt":"drilling-machine","src":"/icons/drilling-machine.svg"},"level":"Intermediate"},{"id":4,"title":"React Performance Optimization Techniques","description":"Building efficient React applications is crucial for providing a smooth user experience. In this article, we’ll explore various techniques to optimize performance in React apps, ensuring that they run smoothly even as they scale.","categories":["Interview","Concept"],"date":"12 August 2024","path":"/blog/react-performance-optimization-techniques","imageProps":{"alt":"performance-svgrepo-com","src":"/icons/performance-svgrepo-com.svg"},"level":"Advanced"},{"id":3,"title":"State Management in React: A Guide to useState, useReducer, and Context API","description":"State management is a crucial aspect of building dynamic React applications. Whether you\'re handling a simple counter or managing complex app-wide data, React provides a set of hooks and tools that make state management easier. In this guide, we\'ll explore three essential tools for managing state in React: useState, useReducer, and the Context API.","categories":["Interview","Concept"],"date":"11 August 2024","path":"/blog/state-management-in-react-a-guide-to-usestate-usereducer-and-context-api","imageProps":{"alt":"redux-svgrepo-com","src":"/icons/redux-svgrepo-com.svg"},"level":"Beginner"},{"id":2,"title":"Understanding the Virtual DOM in React","description":"The Virtual DOM is one of the core concepts that sets React apart from other JavaScript libraries and frameworks. It plays a crucial role in how React updates the UI efficiently and ensures high performance.","categories":["Interview","Concept"],"date":"26 June 2024","path":"/blog/understanding-the-virtual-dom-in-react","imageProps":{"alt":"hierarchy","src":"/icons/hierarchy.svg"},"level":"Beginner"},{"id":1,"title":"5 Fundamental React Hooks Every Developer Should Know","description":"React Hooks are an essential part of modern React development. If you\'re preparing for a job interview, it\'s crucial to understand at least the basic hooks. Here are five fundamental React Hooks you should know","categories":["Interview"],"date":"24 June 2024","path":"/blog/5-fundamental-react-hooks-every-developer-should-know","imageProps":{"alt":"Hook","src":"/icons/hook.svg"},"level":["Beginner"]}]')}},function(e){e.O(0,[1966,2888,9774,179],function(){return e(e.s=414)}),_N_E=e.O()}]);