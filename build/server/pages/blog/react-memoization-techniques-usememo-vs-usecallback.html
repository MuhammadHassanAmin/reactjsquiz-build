<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>React Memoization Techniques: useMemo vs useCallback</title><meta name="google-adsense-account" content="ca-pub-7544108447932228"/><meta name="impact-site-verification" value="a0e1a89a-390d-4f5b-97ae-da930b270628"/><meta name="description" content="Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again."/><meta http-equiv="content-language" content="en-gb"/><link rel="icon" href="/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZW8BQT2FR5"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-ZW8BQT2FR5', {
              page_path: window.location.pathname,
            });
          </script><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7544108447932228" crossorigin="anonymous"></script><meta name="next-head-count" content="15"/><link rel="preload" href="/_next/static/css/222c299d9336c0a0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/222c299d9336c0a0.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-f617077954ce11a7.js" defer=""></script><script src="/_next/static/chunks/framework-a9bb0a3aa321677c.js" defer=""></script><script src="/_next/static/chunks/main-c0ef008321023cfb.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f5a9f1f8a38f6156.js" defer=""></script><script src="/_next/static/chunks/41966-229f1b3ffe43d0af.js" defer=""></script><script src="/_next/static/chunks/pages/blog/react-memoization-techniques-usememo-vs-usecallback-77c2d00a0e0fd97f.js" defer=""></script><script src="/_next/static/bO9wgJRBsQa1avK3N17YI/_buildManifest.js" defer=""></script><script src="/_next/static/bO9wgJRBsQa1avK3N17YI/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="border-b"><nav class="bg-white shadow dark:bg-gray-800"><div class="container px-6 py-3 mx-auto md:flex "><div class="flex items-center justify-between w-full  "><a href="/"><span class="whitespace-nowrap text-2xl font-bold text-gray-800 transition-colors duration-200 transform dark:text-white lg:text-3xl hover:text-gray-700 dark:hover:text-gray-300">React JS Quiz</span></a><div class="flex md:hidden"><button type="button" class="text-gray-500 dark:text-gray-200 hover:text-gray-600 dark:hover:text-gray-400 focus:outline-none focus:text-gray-600 dark:focus:text-gray-400" aria-label="toggle menu"><svg viewBox="0 0 24 24" class="w-6 h-6 fill-current"><path fill-rule="evenodd" d="M4 5h16a1 1 0 0 1 0 2H4a1 1 0 1 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2zm0 6h16a1 1 0 0 1 0 2H4a1 1 0 0 1 0-2z"></path></svg></button></div></div><div class="w-full md:flex md:items-center md:justify-end hidden"><div class="flex flex-col px-2 py-3 -mx-4 md:flex-row md:mx-0 md:py-0 text-2xl"><a class="flex mb-1" href="/"><span class="px-2 py-1 w-full  text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2">Home</span></a><a class="flex mb-1" href="/blog"><span class="px-2 py-1 w-full  text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2">Blog</span></a><a class="flex mb-1" href="/privacy-policy"><span class="px-2 py-1 w-full  text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2">Privacy Policy</span></a><a class="flex mb-1" href="/contact-us"><span class="px-2 py-1 w-full  text-sm font-medium text-gray-700 transition-colors duration-200 transform rounded dark:text-gray-200 hover:bg-gray-900 hover:text-gray-100 md:mx-2">Contact Us</span></a></div></div></div></nav></header><main class=" flex flex-col justify-center items-center py-5 h-full"><article class="p-6 px-6 md:px-10 dark:text-white rounded-lg overflow-hidden"><header class="mb-4"><h1 class="text-2xl md:text-4xl font-bold text-center mb-8 break-words">React Memoization Techniques: useMemo vs useCallback</h1><div class="border-y border-stone-500 py-2 my-4 text-center text-xs md:text-sm break-words"><span class="block">Category: <!-- -->Interview, Concept</span><span class="block mx-5">Difficulty: <!-- -->Intermediate</span><span class="block">Published on: <!-- -->1 September 2024</span></div></header><div class="break-words"><div class="container mx-auto px-4 py-8"><p class="mb-4">Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again. In React, memoization helps in optimizing the rendering process, especially when dealing with complex components or expensive operations. Two common hooks used for memoization in React are <code>useMemo</code> and<!-- --> <code>useCallback</code>. In this article, we’ll dive into what these hooks are, how they work, and when to use each.</p><h2 class="text-2xl font-semibold mb-4">Understanding Memoization in React</h2><p class="mb-4">React’s rendering process can be optimized using memoization techniques. When a component re-renders, React checks if the output of the component has changed. If the output hasn’t changed, React can skip rendering and reuse the previous output, which improves performance. Memoization helps achieve this by caching the results of function calls or component renders based on their dependencies.</p><h2 class="text-2xl font-semibold mb-4">The <code>useMemo</code> Hook</h2><p class="mb-4">The <code>useMemo</code> hook is used to memoize expensive calculations or derived values within a component. It returns a memoized value that only changes when one of its dependencies changes. This can help avoid unnecessary recalculations and improve performance. Here’s the basic syntax of <code>useMemo</code>:</p><div class="w-full overflow-x-auto max-w-[350px] md:max-w-none"><pre class="bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 text-slate-300"><code class="whitespace-pre-wrap break-words">const memoizedValue = useMemo(() =&gt; {
  // Expensive calculation
  return computedValue;
}, [dependencies]);</code></pre></div><p class="mb-4">In this example, the expensive calculation will only be recomputed if one of the <code>dependencies</code> changes. Otherwise, the previously memoized value will be returned, avoiding redundant calculations.</p><h3 class="text-xl font-medium mb-4">Example: Memoizing a Computed Value</h3><p class="mb-4">Let’s say you have a component that performs an expensive calculation based on some props. You can use <code>useMemo</code> to optimize this:</p><div class="w-full overflow-x-auto max-w-[350px] md:max-w-none"><pre class="bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 text-slate-300"><code class="whitespace-pre-wrap break-words">import React, { useMemo } from &#x27;react&#x27;;

function ExpensiveComponent({ data }) {
  const processedData = useMemo(() =&gt; {
    // Simulate an expensive calculation
    return data.reduce((acc, item) =&gt; acc + item.value, 0);
  }, [data]);

  return &lt;div&gt;Total: {processedData}&lt;/div&gt;;
}</code></pre></div><p class="mb-4">In this example, the <code>processedData</code> calculation will only be recomputed if the <code>data</code> prop changes, improving performance by avoiding unnecessary recalculations.</p><h2 class="text-2xl font-semibold mb-4">The <code>useCallback</code> Hook</h2><p class="mb-4">The <code>useCallback</code> hook is used to memoize callback functions, preventing their recreation on every render. This is particularly useful when passing callbacks to child components that depend on reference equality to prevent unnecessary re-renders. Here’s the basic syntax of <code>useCallback</code>:</p><div class="w-full overflow-x-auto max-w-[350px] md:max-w-none"><pre class="bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 text-slate-300"><code class="whitespace-pre-wrap break-words">const memoizedCallback = useCallback(() =&gt; {
  // Callback logic
}, [dependencies]);</code></pre></div><p class="mb-4">In this example, the <code>memoizedCallback</code> will only be recreated if one of its <code>dependencies</code> changes. This ensures that the same function reference is used unless dependencies change.</p><h3 class="text-xl font-medium mb-4">Example: Memoizing a Callback Function</h3><p class="mb-4">Suppose you have a component with a callback function that is passed to a child component. You can use <code>useCallback</code> to memoize this function:</p><div class="w-full overflow-x-auto max-w-[350px] md:max-w-none"><pre class="bg-slate-100 dark:bg-gray-700 p-4 rounded mb-4 text-slate-300"><code class="whitespace-pre-wrap break-words">import React, { useCallback } from &#x27;react&#x27;;
import ChildComponent from &#x27;./ChildComponent&#x27;;

function ParentComponent() {
  const handleClick = useCallback(() =&gt; {
    console.log(&#x27;Button clicked&#x27;);
  }, []);

  return &lt;ChildComponent onClick={handleClick} /&gt;;
}</code></pre></div><p class="mb-4">In this example, the <code>handleClick</code> function will only be recreated if its dependencies change (in this case, there are no dependencies). This ensures that the <code>ChildComponent</code> <!-- -->receives the same function reference unless it needs to change.</p><h2 class="text-2xl font-semibold mb-4">When to Use <code>useMemo</code> vs <code>useCallback</code></h2><p class="mb-4">Both <code>useMemo</code> and <code>useCallback</code> serve different purposes, and choosing between them depends on what you need to optimize:</p><ul class="list-disc pl-6 mb-4"><li class="mb-2">Use <code>useMemo</code> when you need to memoize the result of a computation or derived value. It’s useful for expensive calculations that you want to avoid recomputing unnecessarily.</li><li class="mb-2">Use <code>useCallback</code> when you need to memoize a function that is passed to child components. It’s useful for preventing unnecessary re-renders of child components that rely on reference equality.</li></ul><p class="mb-4">In summary, both hooks are valuable tools in optimizing React applications. Use <code>useMemo</code> to cache computed values and<!-- --> <code>useCallback</code> to cache functions, helping you avoid performance bottlenecks and unnecessary re-renders.</p></div></div></article></main><footer class="bg-white dark:bg-gray-800 dark:text-white p-5 border-t-2  flex flex-col justify-center items-center "></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"id":8,"title":"React Memoization Techniques: useMemo vs useCallback","description":"Memoization is a performance optimization technique used to avoid redundant calculations by storing the results of expensive function calls and reusing them when the same inputs occur again.","categories":["Interview","Concept"],"date":"1 September 2024","path":"/blog/react-memoization-techniques-usememo-vs-usecallback","imageProps":{"alt":"post-it.svg","src":"/icons/post-it.svg"},"level":"Intermediate","siteName":"React JS Quiz","google_analytics_tracking_id":"G-ZW8BQT2FR5","google_adsense_publisher_id":"pub-7544108447932228"},"__N_SSG":true},"page":"/blog/react-memoization-techniques-usememo-vs-usecallback","query":{},"buildId":"bO9wgJRBsQa1avK3N17YI","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>